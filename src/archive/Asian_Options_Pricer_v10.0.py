# -*- coding: utf-8 -*-
"""Pricer_FINAL_v15_0

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fkbdI6gv3XV-pRJINI3C9klRIuGylLDX

# Asian Options Pricing & Hedging

Course: FE 620: Pricing & Hedging | Stevens Institute of Technology

Advisor: Dan Pirjol

Group: Theo Dimitrasopoulos, Will Kraemer, Vaikunth Seshadri, Snehal Rajguru

Link: https://colab.research.google.com/drive/1fkbdI6gv3XV-pRJINI3C9klRIuGylLDX

*Version: v15.0*

## Comments:

**Instructions:**

* Click the execution button on the top left corner of each code cell to execute it. To run all cells in descending order, go to the menu bar at the top and click Runtime -> Run all (or use the **Ctrl-F9** or **⌘-F9** hotkey for Windows and MacOSX respectively);
* If the code is running slowly, go to Runtime -> Change runtime type, and change the Runtime Shape to High-RAM from the dropdown menu;
* The **"!pip install"** lines under the Python packages section (i.e. lines 3-5) only need to be executed the first time you run the notebook. If you receive the message **"Requirement already satisfied:"**, wrap them in treble quotes (add the quotes in lines 2 & 6)*.

**Professor feedback:**
* You could repeat the [MC simulation](https://colab.research.google.com/drive/1fkbdI6gv3XV-pRJINI3C9klRIuGylLDX#scrollTo=Llfmlvyx2J1W&line=5&uniqifier=1) for 100,1000,10k runs and plot the errors vs #runs. The error should scale like 1/sqrt(runs). A log-log plot should be a line with slope -1/2. [DONE]
* An additional test could take several numbers of MC samples (iterations) and plot the log(error) vs log(iterations). Even 2 or 3 points would be sufficient. They should line up on a straight line with slope -0.5 corresponding to the 1/sqrt(N) scaling expected for [MC simulations](https://colab.research.google.com/drive/1fkbdI6gv3XV-pRJINI3C9klRIuGylLDX#scrollTo=Llfmlvyx2J1W&line=5&uniqifier=1) [DONE].

## Python Packages
"""

# Install packages
'''
!pip install -q numpy
!pip install -q matplotlib
!pip install -q scipy
!pip install -q quandl
!pip install -q yfinance
!pip install -q pandas
'''

# Import Packages
import math
import random
import numpy as np
#######
from scipy.stats import norm
from scipy.integrate import quad
#######
import matplotlib as mpl
import mpl_toolkits.mplot3d.axes3d as p3
import matplotlib.pyplot as plt
from matplotlib import cm
#######
import tensorflow.compat.v1 as tf

tf.disable_v2_behavior()
#######
# import pandas as pd
# import quandl
# import timeit

"""## Parameters"""

# Initial Underlying Price
S0 = 100  # @param {type:"number"}

# Risk-free rate (also known as the drift coefficient)
r = 0.15  # @param {type:"number"}

# Dividend Yield Rate
q = 0.0  # @param {type:"number"}

# Valuation Date
t = 0.0  # @param {type:"number"}

# Maturity
T = 1.0  # @param {type:"number"}

# Strike
K = 95  # @param {type:"number"}

# Volatility (also known as the diffusion coefficient)
sigma = 0.3  # @param {type:"number"}

# Number of Iterations for Monte Carlo Simulation
it = 1000  # @param {type:"integer"}

# Time Steps
N = 100000  # @param {type:"integer"}

"""## Plotting"""

# Universal Plot width
width = 25  # @param {type:"integer"}

# Universal Plot height
height = 14  # @param {type:"integer"}

# Universal xtick size
xtick_size = 8  # @param {type:"integer"}

# Universal ytick size
ytick_size = 8  # @param {type:"integer"}

# Universal title font size
title_size = 18  # @param {type:"integer"}

# Universal xlabel font size
xlabel_size = 12  # @param {type:"integer"}

# Universal xlabel font size
ylabel_size = 12  # @param {type:"integer"}

# Universal legend font size
legend_size = 10  # @param {type:"integer"}

plt.rcParams['figure.figsize'] = (width, height)
params = {'text.color': 'w',
          'xtick.color': 'w',
          'ytick.color': 'w',
          'xtick.labelsize': xtick_size,
          'ytick.labelsize': ytick_size,
          'legend.loc': 'upper left',
          }
plt.rcParams.update(params)

"""## Definitions

### Brownian Path Generator
"""


def bm_paths(N):
    seed = random.random()
    dt = T / N
    b_dt = np.random.normal(0., 1., N) * np.sqrt(dt)
    W = np.cumsum(b_dt)
    return W


"""### Geometric Brownian Path Generator

#### Conventional Implementation:
"""


# NORMAL IMPLEMENTATION:
def gbm_paths(S0, K, T, t, r, q, sigma):
    t = np.linspace(0, T, N)
    b_t = np.random.normal(0., 1., int(N)) * np.sqrt(T / N)
    W = np.cumsum(b_t)
    S = S0 * np.exp(sigma * W + (r - q - 0.5 * (sigma ** 2)) * t)
    S = np.insert(S, 0, S0)
    return S


"""#### Tensorflow Implementation:"""


def tf_graph_gbm_paths():
    S0 = tf.placeholder(tf.float32)
    K = tf.placeholder(tf.float32)
    dt = tf.placeholder(tf.float32)
    T = tf.placeholder(tf.float32)
    sigma = tf.placeholder(tf.float32)
    r = tf.placeholder(tf.float32)
    dw = tf.placeholder(tf.float32)
    S_i = S0 * tf.cumprod(tf.exp((r - sigma ** 2 / 2) * dt + sigma * tf.sqrt(dt) * dw), axis=1)
    return (S0, K, dt, T, sigma, r, dw, S_i)


def tf_gbm_paths():
    (S0, K, dt, T, sigma, r, dw, S_i) = tf_graph_gbm_paths()

    def paths(S_zero, strk, maturity, riskfrate, volatility, seed, iterations, timesteps):
        if seed != 0:
            np.random.seed(seed)
        stdnorm_random_variates = np.random.randn(iterations, timesteps)
        with tf.Session() as sess:
            delta_t = maturity / timesteps
            res = sess.run(S_i,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: delta_t,
                               T: maturity,
                               dw: stdnorm_random_variates})
            return res

    return paths


"""### Black-Scholes Theoretical Price
Call and Put Asian option prices with geometric averaging. The alternative implementation in Tensorlfow offers efficiency and includes the calculations of 1st 2nd and 3rd order Greeks.

#### Conventional Implementation
"""


# Call Options:
def bsm_call(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * T - ((sigma ** 2) * T) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    d2 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) - 0.5 * (Sigma_G ** 2) * (T - t))
    c = np.exp(-r * (T - t)) * (G0 * norm.cdf(d1) - K * norm.cdf(d2))
    return c


# Put Options:
def bsm_put(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * T - ((sigma ** 2) * T) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    d2 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) - 0.5 * (Sigma_G ** 2) * (T - t))
    p = np.exp(-r * (T - t)) * (K * norm.cdf(-d2) - G0 * norm.cdf(-d1))
    return p


"""#### Tensorflow Implementation"""


# Call Options:
def bsm_call_tf(enable_greeks=False):
    S0 = tf.placeholder(tf.float32)
    K = tf.placeholder(tf.float32)
    dt = tf.placeholder(tf.float32)
    sigma = tf.placeholder(tf.float32)
    r = tf.placeholder(tf.float32)
    q = tf.placeholder(tf.float32)
    G0 = S0 * tf.exp(0.5 * (r * dt) - ((tf.math.square(sigma)) * dt) / 12)
    Sigma_G = sigma / tf.sqrt(3.0)
    Phi = tf.distributions.Normal(0., 1.).cdf
    d_1 = (1 / (Sigma_G * tf.sqrt(dt))) * (tf.log(G0 / K) + 0.5 * (tf.math.square(Sigma_G)) * dt)
    d_2 = (1 / (Sigma_G * tf.sqrt(dt))) * (tf.log(G0 / K) - 0.5 * (tf.math.square(Sigma_G)) * dt)
    npv = tf.exp(-r * dt) * (G0 * Phi(d_1) - K * Phi(d_2))  # GREEKS TABLE:
    target_calc = [npv]  # (e.g. Option Price with respect to Asset Price (S) is delta)
    if enable_greeks:  # Asset Price (S)   Volatility    Time to Expiry
        greeks = tf.gradients(npv, [S0, sigma, dt])  # Option Price |     delta            vega           theta
        dS_2nd = tf.gradients(greeks[0], [S0, sigma, dt])  # Delta        |     gamma            vanna          charm
        dsigma_2nd = tf.gradients(greeks[1], [S0, sigma, dt])  # Vega         |     vanna         vomma/volga       veta
        dT_2nd = tf.gradients(dS_2nd[0], [S0, sigma, dt])  # Gamma        |     speed            zomma          color
        dsigma_3rd = tf.gradients(dsigma_2nd[1],
                                  [S0, sigma, dt])  # Vomma        |      N/A             ultima         totto

    def execute_graph(S_zero, strk, maturity, riskfrate, volatility):
        with tf.Session() as sess:
            res = sess.run(target_calc,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: maturity})
        return res

    return execute_graph


# Put Options:
def bsm_put_tf(enable_greeks=False):
    S0 = tf.placeholder(tf.float32)
    K = tf.placeholder(tf.float32)
    dt = tf.placeholder(tf.float32)
    sigma = tf.placeholder(tf.float32)
    r = tf.placeholder(tf.float32)
    q = tf.placeholder(tf.float32)
    G0 = S0 * tf.exp(0.5 * (r * dt) - ((tf.math.square(sigma)) * dt) / 12)
    Sigma_G = sigma / tf.sqrt(3.0)
    Phi = tf.distributions.Normal(0., 1.).cdf
    d_1 = (1 / (Sigma_G * tf.sqrt(dt))) * (tf.log(G0 / K) + 0.5 * (tf.math.square(Sigma_G)) * dt)
    d_2 = (1 / (Sigma_G * tf.sqrt(dt))) * (tf.log(G0 / K) - 0.5 * (tf.math.square(Sigma_G)) * dt)
    npv = tf.exp(-r * dt) * (K * Phi(-d_2) - G0 * Phi(-d_1))  # GREEKS TABLE:
    target_calc = [npv]  # (e.g. Option Price with respect to Asset Price (S) is delta)
    if enable_greeks:  # Asset Price (S)   Volatility    Time to Expiry
        greeks = tf.gradients(npv, [S0, sigma, dt])  # Option Price |     delta            vega           theta
        dS_2nd = tf.gradients(greeks[0], [S0, sigma, dt])  # Delta        |     gamma            vanna          charm
        dsigma_2nd = tf.gradients(greeks[1], [S0, sigma, dt])  # Vega         |     vanna         vomma/volga       veta
        dT_2nd = tf.gradients(dS_2nd[0], [S0, sigma, dt])  # Gamma        |     speed            zomma          color
        dsigma_3rd = tf.gradients(dsigma_2nd[1],
                                  [S0, sigma, dt])  # Vomma        |      N/A             ultima         totto
        target_calc += [greeks, dS_2nd, dsigma_2nd, dT_2nd, dsigma_3rd]

    def execute_graph(S_zero, strk, maturity, riskfrate, volatility):
        with tf.Session() as sess:
            res = sess.run(target_calc,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: maturity})
        return res

    return execute_graph


"""### Monte Carlo Simulator with Arithmetic Average (TODO)
Call and Put Asian option prices with arithmetic averaging. The alternative implementation in Tensorlfow offers efficiency and includes the calculations of 1st 2nd and 3rd order Greeks.

#### Conventional Interpretation
"""


# Call Options:
def mc_call_arithm(S0, K, T, t, r, q, sigma, it, N):
    mc_call_arithm_payoffs = []
    for i in range(1, it):
        S = gbm_paths(S0, K, T, t, r, q, sigma)
        S_arithm = np.sum(S) / len(S)
        mc_call_arithm_payoffs.append(np.exp(-r * T) * max(S_arithm - K, 0))
    c = np.mean(mc_call_arithm_payoffs)
    return c


# Put Options:
def mc_put_arithm(S0, K, T, t, r, q, sigma, it, N):
    mc_put_arithm_payoffs = []
    for i in range(1, it):
        S = gbm_paths(S0, K, T, t, r, q, sigma)
        S_arithm = np.sum(S) / len(S)
        mc_put_arithm_payoffs.append(np.exp(-r * T) * max(K - S_arithm, 0))
    p = np.mean(mc_put_arithm_payoffs)
    return p


"""#### Tensorflow Implementation:"""


# Call Options:
def mc_call_arithm_tf(enable_greeks=False):
    (S0, K, dt, T, sigma, r, dw, S_i) = tf_graph_gbm_paths()
    A = tf.reduce_sum(S_i, axis=1) / (T / dt)
    payout = tf.maximum(A - K, 0)
    npv = tf.exp(-r * T) * tf.reduce_mean(payout)
    target_calc = [npv]
    if enable_greeks:
        greeks = tf.gradients(npv, [S0, sigma, dt])  # delta, vega, theta
        dS_2nd = tf.gradients(greeks[0], [S0, sigma, dt])  # gamma, vanna, charm
        dsigma_2nd = tf.gradients(greeks[1], [S0, sigma, dt])  # vanna, vomma/volga, veta
        dT_2nd = tf.gradients(dS_2nd[0], [S0, sigma, dt])  # speed, zomma, color
        dsigma_3rd = tf.gradients(dsigma_2nd[1], [S0, sigma, dt])  # N/A, ultima, totto
        target_calc += [greeks, dS_2nd, dsigma_2nd, dT_2nd, dsigma_3rd]

    def pricer(S_zero, strk, maturity, volatility, riskfrate, seed, iterations, timesteps):
        if seed != 0:
            np.random.seed(seed)
        stdnorm_random_variates = np.random.randn(iterations, timesteps)
        with tf.Session() as sess:
            delta_t = maturity / timesteps
            res = sess.run(target_calc,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: delta_t,
                               T: maturity,
                               dw: stdnorm_random_variates})
            return res

    return pricer


# Put Options:
def mc_put_arithm_tf(enable_greeks=False):
    (S0, K, dt, T, sigma, r, dw, S_i) = tf_graph_gbm_paths()
    A = tf.reduce_sum(S_i, axis=1) / (T / dt)
    payout = tf.maximum(K - A, 0)
    npv = tf.exp(-r * T) * tf.reduce_mean(payout)
    target_calc = [npv]
    if enable_greeks:
        greeks = tf.gradients(npv, [S0, sigma, dt])  # delta, vega, theta
        dS_2nd = tf.gradients(greeks[0], [S0, sigma, dt])  # gamma, vanna, charm
        dsigma_2nd = tf.gradients(greeks[1], [S0, sigma, dt])  # vanna, vomma/volga, veta
        dT_2nd = tf.gradients(dS_2nd[0], [S0, sigma, dt])  # speed, zomma, color
        dsigma_3rd = tf.gradients(dsigma_2nd[1], [S0, sigma, dt])  # N/A, ultima, totto
        target_calc += [greeks, dS_2nd, dsigma_2nd, dT_2nd, dsigma_3rd]

    def pricer(S_zero, strk, maturity, volatility, riskfrate, seed, iterations, timesteps):
        if seed != 0:
            np.random.seed(seed)
        stdnorm_random_variates = np.random.randn(iterations, timesteps)
        with tf.Session() as sess:
            delta_t = maturity / timesteps
            res = sess.run(target_calc,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: delta_t,
                               T: maturity,
                               dw: stdnorm_random_variates})
            return res

    return pricer


"""### Monte Carlo Simulator with Geometric Average

#### Conventional Implementation
"""


# Call Options:
def mc_call_geom(S0, K, T, t, r, q, sigma, it, N):
    mc_call_geom_payoffs = []
    for i in range(1, it):
        S = gbm_paths(S0, K, T, t, r, q, sigma)
        S_geom = np.exp(np.mean(np.log(S)))
        mc_call_geom_payoffs.append(np.exp(-r * T) * max(S_geom - K, 0))
    c = np.mean(mc_call_geom_payoffs)
    return c


# Put Options:
def mc_put_geom(S0, K, T, t, r, q, sigma, it, N):
    mc_put_geom_payoffs = []
    for i in range(1, it):
        S = gbm_paths(S0, K, T, t, r, q, sigma)
        S_geom = np.exp(np.mean(np.log(S)))
        mc_put_geom_payoffs.append(np.exp(-r * T) * max(K - S_geom, 0))
    p = np.mean(mc_put_geom_payoffs)
    return p


"""#### Tensorflow Implementation"""


# Call Options:
def mc_call_geom_tf(enable_greeks=True):
    (S0, K, dt, T, sigma, r, dw, S_i) = tf_graph_gbm_paths()
    A = tf.pow(tf.reduce_prod(S_i, axis=1), dt / T)
    payout = tf.maximum(A - K, 0)
    npv = tf.exp(-r * T) * tf.reduce_mean(payout)  # GREEKS TABLE:
    target_calc = [npv]  # (e.g. Option Price with respect to Asset Price (S) is delta)
    if enable_greeks:  # Asset Price (S)   Volatility    Time to Expiry
        greeks = tf.gradients(npv, [S0, sigma, dt])  # Option Price |     delta            vega           theta
        dS_2nd = tf.gradients(greeks[0], [S0, sigma, dt])  # Delta        |     gamma            vanna          charm
        dsigma_2nd = tf.gradients(greeks[1], [S0, sigma, dt])  # Vega         |     vanna         vomma/volga       veta
        dT_2nd = tf.gradients(dS_2nd[0], [S0, sigma, dt])  # Gamma        |     speed            zomma          color
        dsigma_3rd = tf.gradients(dsigma_2nd[1],
                                  [S0, sigma, dt])  # Vomma        |      N/A             ultima         totto
        target_calc += [greeks, dS_2nd, dsigma_2nd, dT_2nd, dsigma_3rd]

    def pricer(S_zero, strk, maturity, riskfrate, volatility, seed, iterations, timesteps):
        if seed != 0:
            np.random.seed(seed)
        stdnorm_random_variates = np.random.randn(iterations, timesteps)
        with tf.Session() as sess:
            delta_t = maturity / timesteps
            res = sess.run(target_calc,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: delta_t,
                               T: maturity,
                               dw: stdnorm_random_variates})
            return res

    return pricer


# Put Options:
def mc_put_geom_tf(enable_greeks=True):
    (S0, K, dt, T, sigma, r, dw, S_i) = tf_graph_gbm_paths()
    A = tf.pow(tf.reduce_prod(S_i, axis=1), dt / T)
    payout = tf.maximum(K - A, 0)
    npv = tf.exp(-r * T) * tf.reduce_mean(payout)  # GREEKS TABLE:
    target_calc = [npv]  # (e.g. Option Price with respect to Asset Price (S) is delta)
    if enable_greeks:  # Asset Price (S)   Volatility    Time to Expiry
        greeks = tf.gradients(npv, [S0, sigma, dt])  # Option Price |     delta            vega           theta
        dS_2nd = tf.gradients(greeks[0], [S0, sigma, dt])  # Delta        |     gamma            vanna          charm
        dsigma_2nd = tf.gradients(greeks[1], [S0, sigma, dt])  # Vega         |     vanna         vomma/volga       veta
        dT_2nd = tf.gradients(dS_2nd[0], [S0, sigma, dt])  # Gamma        |     speed            zomma          color
        dsigma_3rd = tf.gradients(dsigma_2nd[1],
                                  [S0, sigma, dt])  # Vomma        |      N/A             ultima         totto
        target_calc += [greeks, dS_2nd, dsigma_2nd, dT_2nd, dsigma_3rd]

    def pricer(S_zero, strk, maturity, riskfrate, volatility, seed, iterations, timesteps):
        if seed != 0:
            np.random.seed(seed)
        stdnorm_random_variates = np.random.randn(iterations, timesteps)
        with tf.Session() as sess:
            delta_t = maturity / timesteps
            res = sess.run(target_calc,
                           {
                               S0: S_zero,
                               K: strk,
                               r: riskfrate,
                               sigma: volatility,
                               dt: delta_t,
                               T: maturity,
                               dw: stdnorm_random_variates})
            return res

    return pricer


"""#### BSM Option Sensitivity"""


def bsm_plot_values(function, S0):
    plt.figure(figsize=(20, 16.6))
    points = 100

    # Call(K,T) vs. Strike
    plt.subplot(221)
    klist = np.linspace(K - 30, K + 30, points)
    vlist = [function(S0, K, T, t, r, q, sigma) for K in klist]
    plt.plot(klist, vlist)
    plt.grid()
    plt.xlabel('Strike $K$')
    plt.ylabel('Present Value')

    # C(K,T) vs. Time
    plt.subplot(222)
    tlist = np.linspace(0.0001, T, points)
    vlist = [function(S0, K, T, t, r, q, sigma) for T in tlist]
    plt.plot(tlist, vlist)
    plt.grid(True)
    plt.xlabel('Maturity $T$')

    # Call(K,T) vs. r
    plt.subplot(223)
    rlist = np.linspace(0, r, points)
    vlist = [function(S0, K, T, t, r, q, sigma) for r in rlist]
    plt.plot(tlist, vlist)
    plt.grid(True)
    plt.xlabel('r rate $r$')
    plt.ylabel('Present Value')
    plt.axis('tight')

    # C(K,T) vs. Implied Vol.
    plt.subplot(224)
    slist = np.linspace(0.01, sigma, points)
    vlist = [function(S0, K, T, t, r, q, sigma) for sigma in slist]
    plt.plot(slist, vlist)
    plt.grid(True)
    plt.xlabel('Implied Volatility $\sigma$')
    plt.tight_layout()


"""### Monte Carlo Option Sensitivity (TODO)"""


def mc_plot_values(function, S0):
    plt.figure(figsize=(20, 16.6))
    points = 100

    # Call(K,T) vs. Strike
    plt.subplot(221)
    klist = np.linspace(K - 30, K + 30, points)
    vlist = [function(S0, K, T, t, r, q, sigma, it, N) for K in klist]
    plt.plot(klist, vlist)
    plt.grid()
    plt.xlabel('Strike $K$')
    plt.ylabel('Present Value')

    # C(K,T) vs. Time
    plt.subplot(222)
    tlist = np.linspace(0.0001, T, points)
    vlist = [function(S0, K, T, t, r, q, sigma, it, N) for T in tlist]
    plt.plot(tlist, vlist)
    plt.grid(True)
    plt.xlabel('Maturity $T$')

    # Call(K,T) vs. r
    plt.subplot(223)
    rlist = np.linspace(0, r, points)
    vlist = [function(S0, K, T, t, r, q, sigma, it, N) for r in rlist]
    plt.plot(tlist, vlist)
    plt.grid(True)
    plt.xlabel('r rate $r$')
    plt.ylabel('Present Value')
    plt.axis('tight')

    # C(K,T) vs. Implied Vol.
    plt.subplot(224)
    slist = np.linspace(0.01, sigma, points)
    vlist = [function(S0, K, T, t, r, q, sigma, it, N) for sigma in slist]
    plt.plot(slist, vlist)
    plt.grid(True)
    plt.xlabel('Implied Volatility $\sigma$')
    plt.tight_layout()


"""### BSM Greeks"""


def bsm_delta(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    delta = norm.cdf(d1)
    return delta


def bsm_gamma(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    gamma = norm.ppf(d1) / (S0 * sigma * math.sqrt(T - t))
    return gamma


def bsm_theta(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    d2 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) - 0.5 * (Sigma_G ** 2) * (T - t))
    theta = -(S0 * norm.ppf(d1) * sigma / (2 * math.sqrt(T - t)) +
              r * K * math.exp(-r * (T - t)) * norm.cdf(d2))
    return theta


def bsm_rho(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    d2 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) - 0.5 * (Sigma_G ** 2) * (T - t))
    rho = K * (T - t) * math.exp(-r * (T - t)) * norm.cdf(d2)
    return rho


def bsm_vega(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    vega = S0 * norm.ppf(d1) * math.sqrt(T - t)
    return vega


def plot_greeks(function, greek):
    tlist = np.linspace(0.01, T, 25)
    klist = np.linspace(K - 30, K + 30, 25)
    V = np.zeros((len(tlist), len(klist)), dtype=np.float)
    for j in range(len(klist)):
        for i in range(len(tlist)):
            V[i, j] = function(S0, klist[j], tlist[i], t, r, q, sigma)

    # Plots
    x, y = np.meshgrid(klist, tlist)
    fig = plt.figure(figsize=(15, 10))
    plot = p3.Axes3D(fig)
    plot.plot_wireframe(x, y, V)
    plot.set_xlabel('Strike $K$')
    plot.set_ylabel('Maturity $T$')
    plot.set_zlabel('%s(K, T)' % greek)


"""### MC Greeks (TODO)"""


def mc_delta(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    delta = norm.cdf(d1)
    return delta


def mc_gamma(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    gamma = norm.ppf(d1) / (S0 * sigma * math.sqrt(T - t))
    return gamma


def mc_theta(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    d2 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) - 0.5 * (Sigma_G ** 2) * (T - t))
    theta = -(S0 * norm.ppf(d1) * sigma / (2 * math.sqrt(T - t)) +
              r * K * math.exp(-r * (T - t)) * norm.cdf(d2))
    return theta


def mc_rho(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    d2 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) - 0.5 * (Sigma_G ** 2) * (T - t))
    rho = K * (T - t) * math.exp(-r * (T - t)) * norm.cdf(d2)
    return rho


def mc_vega(S0, K, T, t, r, q, sigma):
    G0 = S0 * np.exp(0.5 * (r - q) * (T - t) - ((sigma ** 2) * (T - t)) / 12)
    Sigma_G = sigma / np.sqrt(3)
    d1 = (1 / (Sigma_G * np.sqrt(T - t))) * (np.log(G0 / K) + 0.5 * (Sigma_G ** 2) * (T - t))
    vega = S0 * norm.ppf(d1) * math.sqrt(T - t)
    return vega


def plot_greeks(function, greek):
    tlist = np.linspace(0.01, T, 25)
    klist = np.linspace(K - 30, K + 30, 25)
    V = np.zeros((len(tlist), len(klist)), dtype=np.float)
    for j in range(len(klist)):
        for i in range(len(tlist)):
            V[i, j] = function(S0, klist[j], tlist[i], t, r, q, sigma)

    # Plots
    x, y = np.meshgrid(klist, tlist)
    fig = plt.figure(figsize=(15, 10))
    plot = p3.Axes3D(fig)
    plot.plot_wireframe(x, y, V)
    plot.set_xlabel('Strike $K$')
    plot.set_ylabel('Maturity $T$')
    plot.set_zlabel('%s(K, T)' % greek)


"""## Error Estimation

### Black-Scholes vs. Monte Carlo: Call Options with Geometric Average
"""

print('- - - - - - - - - - - - - - - - -')

for i in range(95, 110, 5):
    bs = bsm_call(S0, i, T, t, r, q, sigma)
    mc = mc_call_geom(S0, i, T, t, r, q, sigma, it, N)
    error = np.abs((bs - mc) / bs) * 100
    print('G_c(K=%d,T=%d):' % (i, T))
    print('Black-Scholes:', bs)
    print('Monte Carlo:', mc)
    print('Error: %f%%' % error)
    print('- - - - - - - - - - - - - - - - -')

"""### Black-Scholes vs. Monte Carlo: Put Options with Geometric Average"""

print('- - - - - - - - - - - - - - - - -')

for i in range(95, 110, 5):
    bs = bsm_put(S0, i, T, t, r, q, sigma)
    mc = mc_put_geom(S0, i, T, t, r, q, sigma, it, N)
    error = np.abs((bs - mc) / bs) * 100
    print('G_p(K=%d,T=%d):' % (i, T))
    print('Black-Scholes:', repr(bs))
    print('Monte Carlo:', repr(mc))
    print('Error:', repr(error), '%')
    print('- - - - - - - - - - - - - - - - -')

"""### Asian call options with Arithmetic Average: Linetsky Test Cases

The arithmetic average option pricer is benchmarked against the test cases in Table B of the Linetsky paper 1 *Exotic spectra, Risk magazine, April 2002. V. Linetsky* (reproduced below):

**%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%**

**C &emsp; r &emsp; &emsp; &emsp; σ &emsp; &emsp; T &emsp; S0 &emsp; EE &emsp; &emsp; &emsp; MC &emsp; &emsp; &emsp; &emsp; &emsp; %Err**

1 &emsp; 0.0200 &emsp; 0.10 &emsp; 1 &emsp; 2.0 &emsp; 0.05602 &emsp; 0.0559860415 &emsp; 0.017

2 &emsp; 0.1800 &emsp; 0.30 &emsp; 1 &emsp; 2.0 &emsp; 0.21850 &emsp; 0.2183875466 &emsp; 0.059

3 &emsp; 0.0125 &emsp; 0.25 &emsp; 2 &emsp; 2.0 &emsp; 0.17250 &emsp; 0.1722687410 &emsp; 0.063

4 &emsp; 0.0500 &emsp; 0.50 &emsp; 1 &emsp; 1.9 &emsp; 0.19330 &emsp; 0.1931737903 &emsp; 0.084

5 &emsp; 0.0500 &emsp; 0.50 &emsp; 1 &emsp; 2.0 &emsp; 0.24650 &emsp; 0.2464156905 &emsp; 0.095

6 &emsp; 0.0500 &emsp; 0.50 &emsp; 1 &emsp; 2.1 &emsp; 0.30640 &emsp; 0.3062203648 &emsp; 0.106

7 &emsp; 0.0500 &emsp; 0.50 &emsp; 2 &emsp; 2.0 &emsp; 0.35030 &emsp; 0.3500952190 &emsp; 0.146

**%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%**

**Notes:**
* *(EE = Eigenfunction Expansion i.e. the Black-Scholes analytic result in 
this algorithm; MC = Monte-Carlo estimate);*
* *All test cases have a strike K = 2.0 and a dividend yield q = 0.0;*

#### Test Cases:
"""

print('- - - - - - - - - - - - - - - - -')
# Test Case 1:
r = 0.02
sigma = 0.1
T = 1
S0 = 2.0

lntk1 = 0.0559860415
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk1 - mc) / lntk1) * 100
print('Case 1 (r=0.02, sigma=0.10, T=1, S0=2.0):')
print('G_c(K=%d,T=%d):' % (2.0, 1))
print('Linetsky:', repr(lntk1))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

print('- - - - - - - - - - - - - - - - -')
# Test Case 2:
r = 0.18
sigma = 0.30
T = 1.0
S0 = 2.0

lntk2 = 0.2183875466
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk2 - mc) / lntk2) * 100
print('Case 2 (r = 0.18, sigma = 0.30, T = 1, S0 = 2.0):')
print('G_c(K=%d,T=%d):' % (2.0, 1))
print('Linetsky:', repr(lntk2))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

print('- - - - - - - - - - - - - - - - -')
# Test Case 3:
r = 0.0125
sigma = 0.25
T = 2.0
S0 = 2.0

lntk3 = 0.1722687410
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk3 - mc) / lntk3) * 100
print('Case 3 (r = 0.0125, sigma = 0.25, T = 2, S0 = 2.0):')
print('G_c(K=%d,T=%d):' % (2.0, 2))
print('Linetsky:', repr(lntk3))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

print('- - - - - - - - - - - - - - - - -')
# Test Case 4:
r = 0.05
sigma = 0.50
T = 1.0
S0 = 1.9

lntk4 = 0.1931737903
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk4 - mc) / lntk4) * 100
print('Case 4 (r = 0.05, sigma = 0.50, T = 1, S0 = 1.9):')
print('G_c(K=%d,T=%d):' % (2.0, 1))
print('Linetsky:', repr(lntk4))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

print('- - - - - - - - - - - - - - - - -')
# Test Case 5:
r = 0.05
sigma = 0.50
T = 1.0
S0 = 2.0

lntk5 = 0.2464156905
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk5 - mc) / lntk5) * 100
print('Case 5 (r = 0.05, sigma = 0.50, T = 1, S0 = 2.0):')
print('G_c(K=%d,T=%d):' % (2.0, 1))
print('Linetsky:', repr(lntk5))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

print('- - - - - - - - - - - - - - - - -')
# Test Case 6:
r = 0.05
sigma = 0.50
T = 1.0
S0 = 2.1

lntk6 = 0.3062203648
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk6 - mc) / lntk6) * 100
print('Case 6 (r = 0.05, sigma = 0.50, T = 1, S0 = 2.1):')
print('G_c(K=%d,T=%d):' % (2.0, 1))
print('Linetsky:', repr(lntk6))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

print('- - - - - - - - - - - - - - - - -')
# Test Case 7:
r = 0.05
sigma = 0.50
T = 2.0
S0 = 2.0

lntk7 = 0.3500952190
mc = mc_call_arithm(S0, 2.0, T, t, r, q, sigma, it, N)
error = np.abs((lntk7 - mc) / lntk7) * 100
print('Case 7 (r = 0.05, sigma = 0.50, T = 2.0, S0 = 2.0):')
print('G_c(K=%d,T=%d):' % (2.0, 2))
print('Linetsky:', repr(lntk7))
print('Monte Carlo:', repr(mc))
print('Error:', repr(error), '%')

print('- - - - - - - - - - - - - - - - -')

"""### Monte Carlo vs. Number of Simulations

The results of 1000,5000,10000,50000,100000,500000,1000000, and 5000000 iterations are compared to the Black-Scholes theoretical price. The errors are then log-plotted against the number of iterations in order to determine the sensitivity of the pricing algorithm to the number of iterations.
"""

it_cases = [5000, 10000, 50000]

# Call Options:
bsm_c = bsm_call(S0, K, T, t, r, q, sigma)
print('The Black-Scholes Theoretical Call Price is:', bsm_c)
errors_c = []

for i in range(0, len(it_cases)):
    seed = np.random.randint(1, 500)
    mc_c = mc_call_geom(S0, K, T, t, r, q, sigma, it_cases[i], N)
    print('For %d iterations, the Monte Carlo Call Price estimate is:' % it_cases[i], mc_c)
    error_c = 100 * (np.abs(mc_c - bsm_c) / bsm_c)
    errors_c.append(error)
print(errors_c)

# Errors v. Simulations Log-Plot:
errors_v_runs = plt.figure()
ax = errors_v_runs.add_subplot(111)
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_title("Errors vs. Simulations (Call)")
ax.plot(it_cases, errors_c, "o-")
print(errors_c)

# Put Options:
bsm_p = bsm_put(S0, K, T, t, r, q, sigma)
print('The Black-Scholes Theoretical Put Price is:', bsm_p)
errors_p = []

for i in range(0, len(it_cases)):
    seed = np.random.randint(1, 500)
    mc_p = mc_put_geom(S0, K, T, t, r, q, sigma, it_cases[i], N)
    print('For %d iterations, the Monte Carlo Put Price estimate is:' % it_cases[i], mc_p)
    error_p = 100 * (np.abs(mc_p - bsm_p) / bsm_p)
    errors_p.append(error_p)
print(errors_p)

# Errors v. Simulations Log-Plot:
errors_v_runs = plt.figure()
ax = errors_v_runs.add_subplot(111)
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_title("Errors vs. Simulations (Put)")
ax.plot(it_cases, errors_p, "o-")

"""### Monte Carlo vs. Number of Timesteps

The results of 1000,5000,10000,50000,100000,500000,1000000, and 5000000 timesteps are compared to the Black-Scholes theoretical price. The errors are then log-plotted against the number of timesteps in order to determine the sensitivity of the pricing algorithm to the number of timesteps.
"""

n_cases = [5000, 10000, 50000]

# Call Options:
bsm_c = bsm_call(S0, K, T, t, r, q, sigma)
print('The Black-Scholes Theoretical Call Price is:', bsm_c)
errors_c = []

for i in range(0, len(n_cases)):
    seed = np.random.randint(1, 500)
    mc_c = mc_call_geom(S0, K, T, t, r, q, sigma, it, n_cases[i])
    print('For %d iterations, the Monte Carlo Call Price estimate is:' % n_cases[i], mc_c)
    error_c = 100 * (np.abs(mc_c - bsm_c) / bsm_c)
    errors_c.append(error)

print(errors_c)

# Errors v. Timesteps Log-Plot:
errors_v_runs = plt.figure()
ax = errors_v_runs.add_subplot(111)
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_title("Errors vs. Simulations (Call)")
ax.plot(n_cases, errors_c, "o-")

# Put Options:
bsm_p = bsm_put(S0, K, T, t, r, q, sigma)
print('The Black-Scholes Theoretical Put Price is:', bsm_p)
errors_p = []

for i in range(0, len(n_cases)):
    seed = np.random.randint(1, 500)
    mc_p = mc_put_geom(S0, K, T, t, r, q, sigma, it, n_cases[i])
    print('For %d iterations, the Monte Carlo Put Price estimate is:' % n_cases[i], mc_p)
    error_p = 100 * (np.abs(mc_p - bsm_p) / bsm_p)
    errors_p.append(error_p)

print(errors_p)

# Errors v. Timesteps Log-Plot:
errors_v_runs = plt.figure()
ax = errors_v_runs.add_subplot(111)
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_title("Errors vs. Simulations (Put)")
ax.plot(n_cases, errors_p, "o-")

"""## Hedging Test

### Daily Data Generation
"""

data_generator = tf_gbm_paths()
prices = [100, 110, 150, 250, 150, 100, 230, 120, 210, 150]
daily_data = np.ones((10, N))
S_geometric = np.ones((10, 1))
payoffs = np.ones((10, 1))
for i in range(0, 10):
    seed = np.random.randint(1, 5000)
    daily_data[i] = data_generator(prices[i], 95, 1.0, 0.15, 0.3, seed, 1, N)
    S_geometric[i] = np.exp(np.mean(np.log(daily_data[i, :])))
    payoffs[i] = np.exp(-r * T) * max(S_geometric[i] - K, 0)

plt.figure(figsize=(width, height))
_ = plt.plot(np.transpose(daily_data))
_ = plt.title('Simulated Stock Prices', fontsize=title_size, color='w')
_ = plt.ylabel('Price', fontsize=ylabel_size, color='w')
_ = plt.xlabel('Time Step', fontsize=xlabel_size, color='w')

plt.figure(figsize=(width, height))
_ = plt.plot(payoffs)
_ = plt.title('Payouts', fontsize=title_size, color='w')
_ = plt.ylabel('Price', fontsize=ylabel_size, color='w')
_ = plt.xlabel('Time Step', fontsize=xlabel_size, color='w')

print(payoffs)

"""### Portfolio Sensitivity

#### BSM (Control)
"""

# BSM Prices:
for i in range(0, len(prices)):
    bsm_plot_values(bsm_call, prices[i])

for i in range(0, len(prices)):
    bsm_plot_values(bsm_put, prices[i])

"""#### Monte Carlo"""

# Monte Carlo Prices:
for i in range(0, len(prices)):
    mc_plot_values(mc_call_geom, prices[i])

for i in range(0, len(prices)):
    mc_plot_values(bsm_put, prices[i])

"""### Estimate Greeks

#### BSM (Control)
"""

plot_greeks(bsm_delta, 'delta')
plot_greeks(bsm_gamma, 'gamma')
plot_greeks(bsm_theta, 'theta')
plot_greeks(bsm_rho, 'rho')
plot_greeks(bsm_vega, 'vega')

"""#### Monte Carlo"""

plot_greeks(mc_delta, 'delta')
plot_greeks(mc_gamma, 'gamma')
plot_greeks(mc_theta, 'theta')
plot_greeks(mc_rho, 'rho')
plot_greeks(mc_vega, 'vega')

"""### Hedged-Unhedged Portfolio Variability (TODO)"""

